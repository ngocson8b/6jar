'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _get2 = require('../utils/get');

var _get3 = _interopRequireDefault(_get2);

var _endsWith = require('lodash/endsWith');

var _endsWith2 = _interopRequireDefault(_endsWith);

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

var _icepick = require('icepick');

var _icepick2 = _interopRequireDefault(_icepick);

var _actionTypes = require('../action-types');

var _actionTypes2 = _interopRequireDefault(_actionTypes);

var _track = require('../utils/track');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function isEvent(event) {
  return !!(event && event.stopPropagation && event.preventDefault);
}

function getValue(event) {
  return isEvent(event) ? event.target.value : event;
}

function isMulti(model) {
  return (0, _endsWith2.default)(model, '[]');
}

var change = (0, _track.trackable)(function (model, value) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // option defaults
  var changeOptions = _extends({
    silent: false,
    multi: isMulti(model)
  }, options);

  return _extends({
    type: _actionTypes2.default.CHANGE,
    model: model,
    value: getValue(value)
  }, changeOptions);
});

var xor = (0, _track.trackable)(function (model, item) {
  var iteratee = arguments.length <= 2 || arguments[2] === undefined ? function (value) {
    return value === item;
  } : arguments[2];
  return function (dispatch, getState) {
    var state = (0, _get3.default)(getState(), model, []);
    var stateWithoutItem = state.filter(function (stateItem) {
      return !iteratee(stateItem);
    });
    var value = state.length === stateWithoutItem.length ? [].concat(_toConsumableArray(state), [item]) : stateWithoutItem;

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: value
    });
  };
});

var push = (0, _track.trackable)(function (model) {
  var item = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  return function (dispatch, getState) {
    var collection = (0, _get3.default)(getState(), model);
    var value = [].concat(_toConsumableArray(collection || []), [item]);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: value
    });
  };
});

var toggle = (0, _track.trackable)(function (model) {
  return function (dispatch, getState) {
    var value = !(0, _get3.default)(getState(), model);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: value
    });
  };
});

var filter = (0, _track.trackable)(function (model) {
  var iteratee = arguments.length <= 1 || arguments[1] === undefined ? _identity2.default : arguments[1];
  return function (dispatch, getState) {
    var collection = (0, _get3.default)(getState(), model);
    var value = collection.filter(iteratee);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: value
    });
  };
});

var reset = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.RESET,
    model: model
  };
});

var map = (0, _track.trackable)(function (model) {
  var iteratee = arguments.length <= 1 || arguments[1] === undefined ? _identity2.default : arguments[1];
  return function (dispatch, getState) {
    var collection = (0, _get3.default)(getState(), model, []);
    var value = collection.map(iteratee);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: value
    });
  };
});

var remove = (0, _track.trackable)(function (model, index) {
  return function (dispatch, getState) {
    var collection = (0, _get3.default)(getState(), model, []);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: _icepick2.default.splice(collection, index, 1),
      removeKeys: [index]
    });
  };
});

var move = (0, _track.trackable)(function (model, indexFrom, indexTo) {
  return function (dispatch, getState) {
    var collection = (0, _get3.default)(getState(), model, []);

    if (indexFrom >= collection.length || indexTo >= collection.length) {
      throw new Error('Error moving array item: invalid bounds ' + indexFrom + ', ' + indexTo);
    }

    var item = collection[indexFrom];
    var removed = _icepick2.default.splice(collection, indexFrom, 1);
    var inserted = _icepick2.default.splice(removed, indexTo, 0, item);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: inserted
    });
  };
});

var merge = (0, _track.trackable)(function (model, values) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model, {});

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: _icepick2.default.merge(value, values)
    });
  };
});

var omit = (0, _track.trackable)(function (model) {
  var props = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model, {});

    var propsArray = typeof props === 'string' ? [props] : props;

    var newValue = propsArray.reduce(function (acc, prop) {
      return _icepick2.default.dissoc(acc, prop);
    }, value);

    dispatch({
      type: _actionTypes2.default.CHANGE,
      model: model,
      value: newValue,
      removeKeys: propsArray
    });
  };
});

var load = (0, _track.trackable)(function (model, values) {
  return change(model, values, {
    silent: true
  });
});

exports.default = {
  change: change,
  filter: filter,
  map: map,
  merge: merge,
  push: push,
  remove: remove,
  move: move,
  reset: reset,
  toggle: toggle,
  xor: xor,
  load: load,
  omit: omit
};