'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _get2 = require('../utils/get');

var _get3 = _interopRequireDefault(_get2);

var _mapValues = require('../utils/map-values');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _actionTypes = require('../action-types');

var _actionTypes2 = _interopRequireDefault(_actionTypes);

var _batchActions = require('./batch-actions');

var _batchActions2 = _interopRequireDefault(_batchActions);

var _utils = require('../utils');

var _track = require('../utils/track');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var focus = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.FOCUS,
    model: model
  };
});

var blur = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.BLUR,
    model: model
  };
});

var setPristine = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_PRISTINE,
    model: model
  };
});

var setDirty = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_DIRTY,
    model: model
  };
});

var setInitial = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_INITIAL,
    model: model
  };
});

var setPending = (0, _track.trackable)(function (model) {
  var pending = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_PENDING,
    model: model,
    pending: pending
  };
});

var setValidity = (0, _track.trackable)(function (model, validity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _defineProperty({
    type: options.errors ? _actionTypes2.default.SET_ERRORS : _actionTypes2.default.SET_VALIDITY,
    model: model
  }, options.errors ? 'errors' : 'validity', validity);
});

var setFieldsValidity = (0, _track.trackable)(function (model, fieldsValidity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return {
    type: _actionTypes2.default.SET_FIELDS_VALIDITY,
    model: model,
    fieldsValidity: fieldsValidity,
    options: options
  };
});

var setErrors = (0, _track.trackable)(function (model, errors) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return setValidity(model, errors, _extends({}, options, {
    errors: true
  }));
});

var setFieldsErrors = (0, _track.trackable)(function (model, fieldsErrors, options) {
  return setFieldsValidity(model, fieldsErrors, _extends({}, options, {
    errors: true
  }));
});

var resetValidity = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.RESET_VALIDITY,
    model: model
  };
});

var resetErrors = resetValidity;

var setTouched = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_TOUCHED,
    model: model
  };
});

var setUntouched = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_UNTOUCHED,
    model: model
  };
});

var asyncSetValidity = (0, _track.trackable)(function (model, validator) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    dispatch(setPending(model, true));

    var done = function done(validity) {
      dispatch(_batchActions2.default.batch(model, [setValidity(model, validity), setPending(model, false)]));
    };

    var immediateResult = validator(value, done);

    if (typeof immediateResult !== 'undefined') {
      done(immediateResult);
    }
  };
});

var setSubmitted = (0, _track.trackable)(function (model) {
  var submitted = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_SUBMITTED,
    model: model,
    submitted: submitted
  };
});

var setSubmitFailed = (0, _track.trackable)(function (model) {
  return {
    type: _actionTypes2.default.SET_SUBMIT_FAILED,
    model: model
  };
});

var setViewValue = (0, _track.trackable)(function (model, value) {
  return {
    type: _actionTypes2.default.SET_VIEW_VALUE,
    model: model,
    value: value
  };
});

var submit = (0, _track.trackable)(function (model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch) {
    dispatch(setPending(model, true));

    var errorsAction = options.fields ? setFieldsErrors : setErrors;

    promise.then(function (response) {
      dispatch(_batchActions2.default.batch(model, [setSubmitted(model, true), setValidity(model, response)]));
    }).catch(function (error) {
      dispatch(_batchActions2.default.batch(model, [setSubmitFailed(model), errorsAction(model, error)]));
    });

    return promise;
  };
});

var submitFields = (0, _track.trackable)(function (model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return submit(model, promise, _extends({}, options, {
    fields: true
  }));
});

var validate = (0, _track.trackable)(function (model, validators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var validity = (0, _utils.getValidity)(validators, value);

    dispatch(setValidity(model, validity));
  };
});

var validateErrors = (0, _track.trackable)(function (model, errorValidators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var errors = (0, _utils.getValidity)(errorValidators, value);

    dispatch(setValidity(model, errors, { errors: true }));
  };
});

function isFormValidWithoutFields(form, fieldsValidity) {
  if (Object.keys(form.validity).length && !(0, _utils.isValid)(form.validity)) {
    return false;
  }

  // TODO: map through form keys without $form
  var valid = Object.keys(form.fields).every(function (fieldKey) {
    if (fieldsValidity.hasOwnProperty(fieldKey)) {
      return true;
    }

    return form.fields[fieldKey].valid;
  });

  return valid;
}

var validateFields = (0, _track.trackable)(function (model, fieldValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    var fieldsValidity = (0, _mapValues2.default)(fieldValidators, function (validator, field) {
      var fieldValue = field ? (0, _get3.default)(value, field) : value;

      var fieldValidity = (0, _utils.getValidity)(validator, fieldValue);

      return fieldValidity;
    });

    var validCB = options.onValid;
    var invalidCB = options.onInvalid;

    if (validCB || invalidCB) {
      var form = (0, _utils.getForm)(getState(), model);
      var formValid = form && !fieldsValidity.hasOwnProperty('') ? isFormValidWithoutFields(form, fieldsValidity) : true;
      var fieldsValid = options.errors ? !(0, _utils.isInvalid)(fieldsValidity) : (0, _utils.isValid)(fieldsValidity);

      if (validCB && formValid && fieldsValid) {
        validCB();
      } else if (invalidCB) {
        invalidCB();
      }
    }

    var fieldsValiditySetter = options.errors ? setFieldsErrors : setFieldsValidity;

    dispatch(fieldsValiditySetter(model, fieldsValidity));
  };
});

var validateFieldsErrors = (0, _track.trackable)(function (model, fieldErrorsValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return validateFields(model, fieldErrorsValidators, _extends({}, options, {
    errors: true
  }));
});

exports.default = {
  asyncSetValidity: asyncSetValidity,
  blur: blur,
  focus: focus,
  submit: submit,
  submitFields: submitFields,
  setDirty: setDirty,
  setErrors: setErrors,
  setInitial: setInitial,
  setPending: setPending,
  setPristine: setPristine,
  setSubmitted: setSubmitted,
  setSubmitFailed: setSubmitFailed,
  setTouched: setTouched,
  setUntouched: setUntouched,
  setValidity: setValidity,
  setFieldsValidity: setFieldsValidity,
  setFieldsErrors: setFieldsErrors,
  resetValidity: resetValidity,
  resetErrors: resetErrors,
  setViewValue: setViewValue,
  validate: validate,
  validateErrors: validateErrors,
  validateFields: validateFields,
  validateFieldsErrors: validateFieldsErrors
};